# -*- coding: utf-8 -*-
"""app.py (Complete Monolithic Backend)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_JwL_HUiT1en5DzsQ-dwR5hgHmTqT086
"""

#
# Monolithic Crypto Payment System - Production-Ready Blueprint
#
# This single-file application is a complete, self-contained system
# for handling crypto payments. It includes the following components:
# 1. A raw TCP/IP listener for physical card terminals.
# 2. A web server for the virtual PC terminal.
# 3. Secure, in-house ISO 8583 message handling.
# 4. In-house payment processing logic.
# 5. Integration with a Firebase/Firestore database for persistence.
# 6. Placeholder for a real crypto payout service.
#

import os
import json
import logging
import socket
import threading
import requests
import time
import random
from datetime import datetime, timedelta

from flask import Flask, request, jsonify, render_template, redirect, url_for, session, flash
from flask_cors import CORS
from web3 import Web3
from tronpy import Tron
from tronpy.keys import PrivateKey
import firebase_admin
from firebase_admin import credentials, firestore, auth

# --- Flask App Configuration ---
app = Flask(__name__)
CORS(app)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
app.secret_key = os.environ.get('FLASK_SECRET_KEY', 'a_secret_key_that_is_very_secure')
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(minutes=30)

# --- NEW: ERC-20 USDT Contract ABI ---
# This is the standard interface definition for the USDT contract on Ethereum.
ERC20_USDT_ABI = '[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_upgradedAddress","type":"address"}],"name":"deprecate","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"deprecated","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_evilUser","type":"address"}],"name":"addBlackList","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"upgradedAddress","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"balances","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"maximumFee","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_token","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"reclaimToken","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"feeBasisPoints","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"isBlackListed","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_blackListedUser","type":"address"}],"name":"removeBlackList","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_initialSupply","type":"uint256"},{"name":"_name","type":"string"},{"name":"_symbol","type":"string"},{"name":"_decimals","type":"uint256"}],"name":"TetherToken","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"name":"newAddress","type":"address"}],"name":"Upgraded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_blackListedUser","type":"address"}],"name":"AddedBlackList","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_removedUser","type":"address"}],"name":"RemovedBlackList","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[],"name":"Deprecate","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"value","type":"uint256"}],"name":"Issue","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"value","type":"uint256"}],"name":"Redeem","type":"event"}]'

# --- Firebase/Firestore Initialization ---
firebase_config = json.loads(os.environ.get('__firebase_config', '{}'))
app_id = os.environ.get('__app_id', 'default-app-id')

db = None
if firebase_config:
    try:
        cred = credentials.Certificate(firebase_config)
        firebase_admin.initialize_app(cred)
        db = firestore.client()
        logging.info("Firebase Admin SDK initialized successfully.")
    except Exception as e:
        logging.error(f"Error initializing Firebase Admin SDK: {e}", exc_info=True)
        db = None

# --- In-House ISO 8583 Message Handling ---
# NOTE: This class is a placeholder. For production, replace this with a robust library
class Iso8583Message:
    def __init__(self, message_str=None):
        self.mti = None
        self.data_elements = {}
        if message_str:
            self.unpack(message_str)

    def unpack(self, message_str):
        try:
            parts = message_str.split('|')
            self.mti = parts[0].split(':')[1]
            data_part = parts[1]
            data_elements = data_part.split(',')
            for element in data_elements:
                key, value = element.split(':')
                self.data_elements[key] = value
        except Exception as e:
            logging.error(f"Failed to unpack ISO message: {e}")
            self.mti = 'ERROR'

    def pack(self, mti, data_elements):
        self.mti = mti
        self.data_elements = data_elements
        data_parts = [f"{key}:{value}" for key, value in self.data_elements.items()]
        message_str = f"MTI:{self.mti}|" + ",".join(data_parts)
        return message_str.encode('ascii')

# --- In-House Business Logic & Crypto Payout Service ---
def initiate_payout(amount, wallet_address):
    """
    Handles the actual crypto payout, routing between TRC-20 and ERC-20.
    """
    logging.info(f"Processor: Initiating payout of {amount} USDT to {wallet_address}...")

    private_key_hex = os.environ.get("PAYOUT_WALLET_PRIVATE_KEY")
    if not private_key_hex:
        logging.error("SECURITY ALERT: PAYOUT_WALLET_PRIVATE_KEY environment variable is not set.")
        return {"status": "failure", "hash": None, "message": "Payout service misconfigured."}

    try:
        # --- TRC-20 (Tron) Payout ---
        if wallet_address.startswith('T'):
            client = Tron(provider='https://api.trongrid.io')
            private_key = PrivateKey(bytes.fromhex(private_key_hex))
            contract = client.get_contract("TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t")
            amount_in_sun = int(float(amount) * 1_000_000)
            txn = (
                contract.functions.transfer(wallet_address, amount_in_sun)
                .with_owner(private_key.public_key.to_base58check_address())
                .fee_limit(100_000_000).build().sign(private_key)
            )
            result = txn.broadcast().wait()
            if result.get('receipt', {}).get('result') == 'SUCCESS':
                tx_hash = txn.txid
                logging.info(f"Processor: TRC-20 Payout successful. Hash: {tx_hash}")
                return {"status": "success", "hash": tx_hash}
            else:
                logging.error(f"Processor: TRC-20 Payout FAILED on-chain. Result: {result}")
                return {"status": "failure", "hash": None}

        # --- ERC-20 (Ethereum) Payout ---
        elif wallet_address.startswith('0x'):
            node_url = os.environ.get("ETHEREUM_NODE_URL")
            if not node_url:
                 logging.error("SECURITY ALERT: ETHEREUM_NODE_URL env var not set.")
                 return {"status": "failure", "hash": None}
            w3 = Web3(Web3.HTTPProvider(node_url))
            account = w3.eth.account.from_key(private_key_hex)
            usdt_contract_address = "0xdAC17F958D2ee523a2206206994597C13D831ec7"
            usdt_contract = w3.eth.contract(address=w3.to_checksum_address(usdt_contract_address), abi=ERC20_USDT_ABI)
            amount_in_wei = int(float(amount) * 1_000_000)
            tx_data = usdt_contract.functions.transfer(
                w3.to_checksum_address(wallet_address), amount_in_wei
            ).build_transaction({
                'from': account.address, 'gas': 200000,
                'gasPrice': w3.eth.gas_price, 'nonce': w3.eth.get_transaction_count(account.address),
            })
            signed_tx = w3.eth.account.sign_transaction(tx_data, account.key)
            tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
            receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
            if receipt['status'] == 1:
                 logging.info(f"Processor: ERC-20 Payout successful. Hash: {tx_hash.hex()}")
                 return {"status": "success", "hash": tx_hash.hex()}
            else:
                 logging.error(f"Processor: ERC-20 Payout FAILED on-chain. Receipt: {receipt}")
                 return {"status": "failure", "hash": tx_hash.hex()}
        else:
            logging.error(f"Unsupported wallet format for '{wallet_address}'.")
            return {"status": "failure", "hash": None}
    except Exception as e:
        logging.error(f"Processor: Crypto payout failed with an exception: {e}", exc_info=True)
        return {"status": "failure", "hash": None}

def process_payment_logic(data):
    # This function now correctly uses the wallet address sent from the frontend
    amount = data.get('amount')
    currency = data.get('currency')
    card_number = data.get('cardNumber')
    protocol = data.get('protocol')
    merchant_wallet = data.get('merchantWallet') # Get wallet from frontend data
    user_id = data.get('userId', 'virtual-terminal-1')

    if not all([amount, currency, card_number, protocol, merchant_wallet]):
        return {"status": "declined", "response_code": "99", "message": "Missing transaction data."}

    is_approved = random.choice([True, True, False]) # Higher approval rate for testing
    blockchain_tx_hash = None
    if is_approved:
        # Call the live payout function with the selected merchant wallet
        payout_result = initiate_payout(amount, merchant_wallet)
        if payout_result['status'] == 'success':
            blockchain_tx_hash = payout_result['hash']
            status_message = "Transaction approved and payout initiated."
            response_code = "00"
        else:
            status_message = "Transaction approved, but payout failed."
            response_code = "05"
    else:
        status_message = "Transaction declined by internal rules."
        response_code = "51"

    log_transaction_to_firestore(user_id, data, {
        "status": "approved" if is_approved and blockchain_tx_hash else "declined",
        "response_code": response_code, "message": status_message,
        "blockchain_hash": blockchain_tx_hash
    })
    return {
        "status": "approved" if is_approved and blockchain_tx_hash else "declined",
        "response_code": response_code, "message": status_message,
        "blockchain_hash": blockchain_tx_hash
    }

def log_transaction_to_firestore(user_id, data, result):
    if not db or not user_id:
        logging.error("Firestore or user ID not available. Cannot log transaction.")
        return

    try:
        transactions_ref = db.collection('artifacts').document(app_id).collection('users').document(user_id).collection('transactions')
        transactions_ref.add({
            'amount': data.get('amount'),
            'currency': data.get('currency'),
            'protocol': data.get('protocol'),
            'cardNumber': data.get('cardNumber'),
            'status': result.get('status'),
            'response_code': result.get('response_code'),
            'blockchain_hash': result.get('blockchain_hash'),
            'timestamp': firestore.SERVER_TIMESTAMP
        })
        logging.info(f"Transaction logged to Firestore for user {user_id}")
    except Exception as e:
        logging.error(f"Error logging to Firestore: {e}", exc_info=True)

def delete_transaction_logic(user_id, transaction_id):
    if not db:
        raise Exception("Database not initialized.")
    transaction_ref = db.collection('artifacts').document(app_id).collection('users').document(user_id).collection('transactions').document(transaction_id)
    transaction_ref.delete()
    return True

# --- Raw TCP/IP Listener for Physical Terminals ---
ISO_GATEWAY_HOST = '0.0.0.0'
ISO_GATEWAY_PORT = 8583

def handle_terminal_connection(conn, addr):
    logging.info(f"Gateway: New connection from {addr}")
    try:
        data = conn.recv(1024).decode('ascii')
        if not data:
            return

        iso_request = Iso8583Message(data)

        payload = {
            'userId': 'physical-terminal-1',
            'amount': float(iso_request.data_elements.get('DE4', 0)),
            'currency': 'USD',
            'cardNumber': iso_request.data_elements.get('DE2', 'N/A'),
            'protocol': 'POS_ISO_RAW'
        }

        result = process_payment_logic(payload)

        iso_response_data = {
            "DE39": result.get('response_code', '99'),
            "DE123": result.get('blockchain_hash', 'NO_HASH')
        }

        iso_response = Iso8583Message().pack("0110", iso_response_data)
        conn.sendall(iso_response)

    except Exception as e:
        logging.error(f"Error handling raw TCP/IP request: {e}")
        error_response = Iso8583Message().pack("0110", {"DE39": "96"})
        conn.sendall(error_response)
    finally:
        conn.close()

def start_tcp_listener():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((ISO_GATEWAY_HOST, ISO_GATEWAY_PORT))
        s.listen()
        logging.info(f"Raw TCP/IP listener started on {ISO_GATEWAY_HOST}:{ISO_GATEWAY_PORT}")
        while True:
            conn, addr = s.accept()
            thread = threading.Thread(target=handle_terminal_connection, args=(conn, addr))
            thread.daemon = True
            thread.start()

# ===============================================================
# --- UI ROUTING AND MODIFIED API ENDPOINTS ---
# ===============================================================

# --- Data for Frontend Templates ---
PROTOCOLS = {
    "POS Terminal -101.1 (4-digit approval)": 4,
    "POS Terminal -101.4 (6-digit approval)": 6,
    "POS Terminal -101.6 (Pre-authorization)": 6,
    "POS Terminal -101.7 (4-digit approval)": 4,
    "POS Terminal -101.8 (PIN-LESS transaction)": 4,
    "POS Terminal -201.1 (6-digit approval)": 6,
    "POS Terminal -201.3 (6-digit approval)": 6,
    "POS Terminal -201.5 (6-digit approval)": 6
}
WALLETS = {
    "USDT ERC-20": "0xYourEthereumWalletAddress_REPLACE_ME",
    "USDT TRC-20": "TMerchaNTWalletAddress_REPLACE_ME"
}

@app.route('/')
def index():
    """Main entry point. Redirects to login or card page based on session."""
    if 'logged_in' in session:
        return redirect(url_for('card_page'))
    # The original index route is now the login page
    return redirect(url_for('login_page'))

@app.route('/login', methods=['GET', 'POST'])
def login_page():
    """Handles user login."""
    if request.method == 'POST':
        # IMPORTANT: Replace with a secure database check
        if request.form['username'] == 'admin' and request.form['password'] == 'password':
            session['logged_in'] = True
            session.permanent = True
            return redirect(url_for('card_page'))
        else:
            flash("Invalid username or password.", "danger")
    return render_template('login.html')

@app.route('/card')
def card_page():
    """Displays the main transaction page. Protected by session."""
    if 'logged_in' not in session:
        flash("You must be logged in to access this page.", "warning")
        return redirect(url_for('login_page'))
    return render_template('card.html', protocols=PROTOCOLS, wallets=WALLETS)

@app.route('/processing')
def processing_page():
    """Displays the processing buffer page."""
    if 'logged_in' not in session:
        return redirect(url_for('login_page'))
    return render_template('processing.html')

@app.route('/success')
def success_page():
    """Displays the transaction success page."""
    if 'logged_in' not in session:
        return redirect(url_for('login_page'))
    return render_template('success.html')

@app.route('/rejected')
def rejected_page():
    """Displays the transaction rejected page."""
    if 'logged_in' not in session:
        return redirect(url_for('login_page'))
    return render_template('rejected.html')

@app.route('/forgot-password')
def forgot_password_page():
    """Displays the forgot password page."""
    return render_template('forgot_password.html')

@app.route('/reset-password')
def reset_password_page():
    """Displays the reset password page."""
    return render_template('reset_password.html')

@app.route('/logout')
def logout():
    """Logs the user out by clearing the session."""
    session.clear()
    flash("You have been logged out.", "info")
    return redirect(url_for('login_page'))


# --- API Endpoints for Web/PC Terminal ---
@app.route('/api/process_transaction', methods=['POST'])
def handle_web_payment():
    """API endpoint called by JavaScript to process the payment."""
    # Add session check for security
    if 'logged_in' not in session:
        return jsonify({"status": "error", "message": "User not authenticated."}), 401
    try:
        data = request.json
        user_id = data.get('userId')
        result = process_payment_logic(data)
        return jsonify(result)
    except Exception as e:
        logging.error(f"Error processing web payment: {e}")
        return jsonify({"status": "declined", "response_code": "99", "message": "Internal Server Error"}), 500

@app.route('/api/delete_transaction', methods=['POST'])
def delete_web_transaction():
    """API endpoint to delete a transaction."""
    if 'logged_in' not in session:
        return jsonify({"status": "error", "message": "User not authenticated."}), 401
    try:
        data = request.json
        user_id = data.get('userId')
        transaction_id = data.get('transactionId')
        delete_transaction_logic(user_id, transaction_id)
        return jsonify({"message": "Transaction deleted successfully."}), 200
    except Exception as e:
        logging.error(f"Error deleting transaction: {e}", exc_info=True)
        return jsonify({"error": "Internal server error."}), 500


if __name__ == '__main__':
    tcp_thread = threading.Thread(target=start_tcp_listener, daemon=True)
    tcp_thread.start()

    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=True, use_reloader=False)
